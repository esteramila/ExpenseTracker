@page "/expenses"
@rendermode InteractiveServer
@using ExpenseTracker.Services;
@using ExpenseTracker.Data.Models;
@using ExpenseTracker.Components; <!-- ExpensesList e aici -->
@inject ExpenseService ExpenseService;
@inject CategoryService CategoryService;
@inject NavigationManager NavigationManager;

<PageTitle>Expenses</PageTitle>
<h3>Expenses</h3>

@if (expenses == null)
{
    <p><em>Loading...</em></p>
}
else
{
    <label for="filter">Filter expenses:</label>
    <select id="filter" @onchange="FilterExpenses">
        <option value="All">All</option>
        <option value="Planned">Planned</option>
        <option value="Unplanned">Unplanned</option>
    </select>

    <p>Total Expenses: @filteredExpenses.Sum(e => e.Amount) RON</p> <!-- Display the total sum of filtered expenses -->

    @* <p>Loaded @filteredExpenses.Count expenses.</p> *@ <!-- Debugging line: ajunge aici -->
    <ExpensesList expenses="filteredExpenses"
        onEditExpense="EditExpense" 
        onDeleteExpense="DeleteExpense" />
}
<button @onclick="NavigateToAddExpense">Add Expense</button>

@* <p>Expenses data: @System.Text.Json.JsonSerializer.Serialize(expenses)</p> <!-- Debugging line: se populeaza expenes cu ce trebe -->
 *@
@code {
    private List<Expense> expenses;
    private string errorMessage;

    private List<Expense> filteredExpenses;
    private string selectedFilter = "All";

    protected override async Task OnInitializedAsync()
    {
        try
        {
            expenses = await ExpenseService.GetAllExpensesAsync();
            // foreach (var expense in expenses)
            // {
            //     expense.Category = await CategoryService.GetCategoryByIdAsync(expense.CategoryId);
            // } //no need to fetch it again, we included the expenses in the category class
            filteredExpenses = new List<Expense>(expenses); // Initially display all expenses
            Console.WriteLine($"Loaded {expenses.Count} expenses."); // Debugging line
        }
        catch (Exception ex)
        {
            errorMessage = GetInnermostExceptionMessage(ex);
            Console.Error.WriteLine(errorMessage);
        }
    }

    private void EditExpense(int id)
    {
        try
        {
            NavigationManager.NavigateTo($"/expenses/{id}");
        }
        catch (Exception ex)
        {
            errorMessage = GetInnermostExceptionMessage(ex);
            Console.Error.WriteLine(errorMessage);
        }
    }

    private async Task DeleteExpense(int id)
    {
        try
        {
            await ExpenseService.DeleteExpenseAsync(id);
            expenses = await ExpenseService.GetAllExpensesAsync();
            ApplyFilter(); // Reapply the filter after deleting an expense
        }
        catch (Exception ex)
        {
            errorMessage = GetInnermostExceptionMessage(ex);
            Console.Error.WriteLine(errorMessage);
        }
    }

    private void NavigateToAddExpense()
    {
        NavigationManager.NavigateTo("/expenses/new");
    }

    private void FilterExpenses(ChangeEventArgs e)
    {
        selectedFilter = e.Value.ToString();
        ApplyFilter();
    }

    private void ApplyFilter()
    {
        if (selectedFilter == "Planned")
        {
            filteredExpenses = expenses.Where(expense => expense.Planned).ToList();
        }
        else if (selectedFilter == "Unplanned")
        {
            filteredExpenses = expenses.Where(expense => !expense.Planned).ToList();
        }
        else
        {
            filteredExpenses = new List<Expense>(expenses);
        }
    }

    private string GetInnermostExceptionMessage(Exception ex)
    {
        while (ex.InnerException != null) ex = ex.InnerException;
        return ex.Message;
    }
}
